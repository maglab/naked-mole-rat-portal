.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::EUtilities::EUtilDataI 3"
.TH Bio::Tools::EUtilities::EUtilDataI 3 "2014-05-21" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::EUtilities::EUtilDataI \- eutil data object interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # say you had some data in a hash ref ($data) and wanted to create hierarchies
\&  # of object using the same interface, starting with the topmost...
\&
\&  # $object is a Bio::Tools::EUtilities::EUtilDataI instance
\&
\&  $object\->_add_data($data);
\&
\&  # in _add_data()... sort through keys and create subobjects as needed
\&
\&  if ($key eq \*(Aqfoo\*(Aq) {
\&     my $sub = Bio::Tools::EUtilities::FooData\->new(\-eutil => \*(Aqefoo\*(Aq,
\&                                                    \-type => \*(Aqfoo\*(Aq);
\&     $sub\->_add_data($subdata);
\&     # store into parent object as needed...
\&     ...
\&   }
\&
\&   # access stored data
\&
\&   while (my $sub = $parent\->next_Foo) {...}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple interface which allows creation of simple typed object
hierarchies. Single layers can be accessed via simple iterators (next_* methods)
or retrieved all at once (get_*) methods; nested data can be iterated through
nested iterators for each object, or retrieved using get_all_* methods.
.PP
This interface defines common methods required for all eutil data-holding
objects: \fI_add_data()\fR, \fIeutil()\fR, and \fItype()\fR. It also specifies inheriting
interface classes use at least one of three methods: \fIget_ids()\fR, \fIget_term()\fR, or
\&\fIget_database()\fR, which are the three types of data that eutils mainly centers on.
.PP
Generally, \fIeutil()\fR is the Bio::Tools::EUtilities parser used to set the data.
Similarly, \fIdatatype()\fR is the specific data type for the class.
.PP
Implementations which rely on subclasses to store data and have iterators should
also define a generalized \fIrewind()\fR method that (by default) rewinds all
iterators to the start. Args passed can specify exactly which iterator to rewind
and (if possible) recursively rewind nested object iterators.
.PP
As the method implies, \fI_add_data()\fR is a private method that adds data chunks to
the object and sets internal parameters for the various data objects. Methods
corresponding to the data type simply return the set data or iterate through the
data sets if the values are more complex. Data can alternatively be passed
through the object constructor.
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to
help us keep track the bugs and their resolution.
Bug reports can be submitted via the web.
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Email cjfields at bioperl dot org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the
object methods. Internal methods are usually
preceded with a _
.SS "eutil"
.IX Subsection "eutil"
.Vb 6
\& Title    : eutil
\& Usage    : $eutil\->$foo\->eutil
\& Function : Get/Set eutil
\& Returns  : string
\& Args     : string (eutil)
\& Throws   : on invalid eutil
.Ve
.SS "datatype"
.IX Subsection "datatype"
.Vb 7
\& Title   : type
\& Usage   : $type = $qd\->datatype;
\& Function: retrieve simple data type object holds (linkset, docsum, item, etc)
\& Returns : string (eutil name)
\& Args    : none
\& Note    : this is probably more useful for devs than for users as a way to keep
\&           track of the various types of modules used
.Ve
.SS "rewind"
.IX Subsection "rewind"
.Vb 5
\& Title    : rewind
\& Usage    : $esum\->rewind
\& Function : rewinds the requested iterator
\& Returns  : none
\& Args     : [OPTIONAL] may include \*(Aqall\*(Aq, \*(Aqrecursive\*(Aq, etc.
.Ve
.SS "_add_data"
.IX Subsection "_add_data"
.Vb 5
\& Title    : _add_data
\& Usage    : $foo\->_add_data($data)
\& Function : adds data to current object as a chunk
\& Returns  : none
\& Args     : hash ref containing relevant data
.Ve
.SS "to_string"
.IX Subsection "to_string"
.Vb 6
\& Title    : to_string
\& Usage    : $foo\->to_string()
\& Function : converts current object to string
\& Returns  : none
\& Args     : (optional) simple data for text formatting
\& Note     : Used generally for debugging and for the print_* methods
.Ve
.SS "_text_wrap"
.IX Subsection "_text_wrap"
.Vb 6
\& Title    : _text_wrap
\& Usage    : $foo\->_text_wrap($string)
\& Function : private internal wrapper for Text::Wrap::wrap
\& Returns  : string
\& Args     : string
\& Note     : Internal use only.  Simple wrapper method.
.Ve
